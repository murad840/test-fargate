"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BatchOperation_1 = require("./BatchOperation");
exports.MAX_READ_BATCH_SIZE = 100;
/**
 * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
 * BatchGetItem operations. The items may be from any number of tables.
 *
 * This method will automatically retry any get requests returned by DynamoDB as
 * unprocessed. Exponential backoff on unprocessed items is employed on a
 * per-table basis.
 */
var BatchGet = /** @class */ (function (_super) {
    tslib_1.__extends(BatchGet, _super);
    /**
     * @param client    The AWS SDK client with which to communicate with
     *                  DynamoDB.
     * @param items     A synchronous or asynchronous iterable of tuples
     *                  describing the reads to execute. The first member of the
     *                  tuple should be the name of the table from which to
     *                  read, and the second should be the marshalled key.
     * @param options   Additional options to apply to the operations executed.
     */
    function BatchGet(client, items, _a) {
        var _b = _a === void 0 ? {} : _a, ConsistentRead = _b.ConsistentRead, _c = _b.PerTableOptions, PerTableOptions = _c === void 0 ? {} : _c;
        var _this = _super.call(this, client, items) || this;
        _this.batchSize = exports.MAX_READ_BATCH_SIZE;
        _this.consistentRead = ConsistentRead;
        _this.options = PerTableOptions;
        return _this;
    }
    BatchGet.prototype.doBatchRequest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var operationInput, batchSize, _a, tableName, item, _b, projection, consistentRead, attributeNames, _c, _d, Responses, _e, UnprocessedKeys, unprocessedTables, _f, _g, table, _h, _j, table, tableData, _k, _l, item, e_1, _m, e_2, _o, e_3, _p;
            return tslib_1.__generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        operationInput = { RequestItems: {} };
                        batchSize = 0;
                        while (this.toSend.length > 0) {
                            _a = tslib_1.__read(this.toSend.shift(), 2), tableName = _a[0], item = _a[1];
                            if (operationInput.RequestItems[tableName] === undefined) {
                                _b = this.state[tableName], projection = _b.projection, consistentRead = _b.consistentRead, attributeNames = _b.attributeNames;
                                operationInput.RequestItems[tableName] = {
                                    Keys: [],
                                    ConsistentRead: consistentRead,
                                    ProjectionExpression: projection,
                                    ExpressionAttributeNames: attributeNames,
                                };
                            }
                            operationInput.RequestItems[tableName].Keys.push(item);
                            if (++batchSize === this.batchSize) {
                                break;
                            }
                        }
                        return [4 /*yield*/, this.client.batchGetItem(operationInput).promise()];
                    case 1:
                        _c = _q.sent(), _d = _c.Responses, Responses = _d === void 0 ? {} : _d, _e = _c.UnprocessedKeys, UnprocessedKeys = _e === void 0 ? {} : _e;
                        unprocessedTables = new Set();
                        try {
                            for (_f = tslib_1.__values(Object.keys(UnprocessedKeys)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                table = _g.value;
                                unprocessedTables.add(table);
                                this.handleThrottled(table, UnprocessedKeys[table].Keys);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_m = _f.return)) _m.call(_f);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        this.movePendingToThrottled(unprocessedTables);
                        try {
                            for (_h = tslib_1.__values(Object.keys(Responses)), _j = _h.next(); !_j.done; _j = _h.next()) {
                                table = _j.value;
                                tableData = this.state[table];
                                tableData.backoffFactor = Math.max(0, tableData.backoffFactor - 1);
                                try {
                                    for (_k = tslib_1.__values(Responses[table]), _l = _k.next(); !_l.done; _l = _k.next()) {
                                        item = _l.value;
                                        this.pending.push([table, item]);
                                    }
                                }
                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                finally {
                                    try {
                                        if (_l && !_l.done && (_p = _k.return)) _p.call(_k);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_j && !_j.done && (_o = _h.return)) _o.call(_h);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BatchGet.prototype.getInitialTableState = function (tableName) {
        var _a = this.options[tableName] || {}, ExpressionAttributeNames = _a.ExpressionAttributeNames, ProjectionExpression = _a.ProjectionExpression, _b = _a.ConsistentRead, ConsistentRead = _b === void 0 ? this.consistentRead : _b;
        return tslib_1.__assign({}, _super.prototype.getInitialTableState.call(this, tableName), { attributeNames: ExpressionAttributeNames, projection: ProjectionExpression, consistentRead: ConsistentRead });
    };
    return BatchGet;
}(BatchOperation_1.BatchOperation));
exports.BatchGet = BatchGet;
//# sourceMappingURL=BatchGet.js.map
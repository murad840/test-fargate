"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function keysFromSchema(schema) {
    var attributes = {};
    var tableKeys = {};
    var indexKeys = {};
    try {
        for (var _a = tslib_1.__values(Object.keys(schema)), _b = _a.next(); !_b.done; _b = _a.next()) {
            var propertyName = _b.value;
            var fieldSchema = schema[propertyName];
            if (fieldSchema.type === 'Binary' ||
                fieldSchema.type === 'Custom' ||
                fieldSchema.type === 'Date' ||
                fieldSchema.type === 'Number' ||
                fieldSchema.type === 'String') {
                var _c = fieldSchema.attributeName, attributeName = _c === void 0 ? propertyName : _c;
                if (fieldSchema.keyType) {
                    attributes[attributeName] = attributeType(fieldSchema);
                    tableKeys[attributeName] = fieldSchema.keyType;
                }
                if (fieldSchema.indexKeyConfigurations &&
                    Object.keys(fieldSchema.indexKeyConfigurations).length > 0) {
                    attributes[attributeName] = attributeType(fieldSchema);
                    try {
                        for (var _d = tslib_1.__values(Object.keys(fieldSchema.indexKeyConfigurations)), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var indexName = _e.value;
                            if (!(indexName in indexKeys)) {
                                indexKeys[indexName] = {};
                            }
                            indexKeys[indexName][attributeName]
                                = fieldSchema.indexKeyConfigurations[indexName];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_g = _a.return)) _g.call(_a);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return { attributes: attributes, tableKeys: tableKeys, indexKeys: indexKeys };
    var e_2, _g, e_1, _f;
}
exports.keysFromSchema = keysFromSchema;
function attributeType(fieldSchema) {
    switch (fieldSchema.type) {
        case 'Binary':
            return 'B';
        case 'Custom':
            if (!fieldSchema.attributeType) {
                throw new Error('Invalid schema: no attribute type defined for custom field');
            }
            return fieldSchema.attributeType;
        case 'Date':
        case 'Number':
            return 'N';
        case 'String':
            return 'S';
    }
}
//# sourceMappingURL=keysFromSchema.js.map
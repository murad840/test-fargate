"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BatchOperation_1 = require("./BatchOperation");
var itemIdentifier_1 = require("./itemIdentifier");
exports.MAX_WRITE_BATCH_SIZE = 25;
/**
 * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or more
 * BatchWriteItem operations. The items may belong to any number of tables.
 *
 * The iterable of writes to perform may be synchronous or asynchronous and is
 * expected to yield tuples describing the writes to be performed. The first
 * member should be the table name, and the second should be {WriteRequest}
 * object that defines either a put request or a delete request.
 *
 * This method will automatically retry any write requests returned by DynamoDB
 * as unprocessed. Exponential backoff on unprocessed items is employed on a
 * per-table basis.
 */
var BatchWrite = /** @class */ (function (_super) {
    tslib_1.__extends(BatchWrite, _super);
    function BatchWrite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.batchSize = exports.MAX_WRITE_BATCH_SIZE;
        return _this;
    }
    BatchWrite.prototype.doBatchRequest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var inFlight, operationInput, batchSize, _a, tableName, marshalled, _b, UnprocessedItems, unprocessedTables, _c, _d, table, unprocessed, _e, _f, item, identifier, i, _g, tableName, attributes, processedTables, inFlight_1, inFlight_1_1, _h, tableName, marshalled, processedTables_1, processedTables_1_1, tableName, e_1, _j, e_2, _k, e_3, _l, e_4, _m;
            return tslib_1.__generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        inFlight = [];
                        operationInput = { RequestItems: {} };
                        batchSize = 0;
                        while (this.toSend.length > 0) {
                            _a = tslib_1.__read(this.toSend.shift(), 2), tableName = _a[0], marshalled = _a[1];
                            inFlight.push([tableName, marshalled]);
                            if (operationInput.RequestItems[tableName] === undefined) {
                                operationInput.RequestItems[tableName] = [];
                            }
                            operationInput.RequestItems[tableName].push(marshalled);
                            if (++batchSize === this.batchSize) {
                                break;
                            }
                        }
                        return [4 /*yield*/, this.client.batchWriteItem(operationInput).promise()];
                    case 1:
                        _b = (_o.sent()).UnprocessedItems, UnprocessedItems = _b === void 0 ? {} : _b;
                        unprocessedTables = new Set();
                        try {
                            for (_c = tslib_1.__values(Object.keys(UnprocessedItems)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                table = _d.value;
                                unprocessedTables.add(table);
                                unprocessed = [];
                                try {
                                    for (_e = tslib_1.__values(UnprocessedItems[table]), _f = _e.next(); !_f.done; _f = _e.next()) {
                                        item = _f.value;
                                        if (item.DeleteRequest || item.PutRequest) {
                                            unprocessed.push(item);
                                            identifier = itemIdentifier_1.itemIdentifier(table, item);
                                            for (i = inFlight.length - 1; i >= 0; i--) {
                                                _g = tslib_1.__read(inFlight[i], 2), tableName = _g[0], attributes = _g[1];
                                                if (tableName === table &&
                                                    itemIdentifier_1.itemIdentifier(tableName, attributes) === identifier) {
                                                    inFlight.splice(i, 1);
                                                }
                                            }
                                        }
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (_f && !_f.done && (_k = _e.return)) _k.call(_e);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                                this.handleThrottled(table, unprocessed);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_j = _c.return)) _j.call(_c);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        this.movePendingToThrottled(unprocessedTables);
                        processedTables = new Set();
                        try {
                            for (inFlight_1 = tslib_1.__values(inFlight), inFlight_1_1 = inFlight_1.next(); !inFlight_1_1.done; inFlight_1_1 = inFlight_1.next()) {
                                _h = tslib_1.__read(inFlight_1_1.value, 2), tableName = _h[0], marshalled = _h[1];
                                processedTables.add(tableName);
                                this.pending.push([tableName, marshalled]);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (inFlight_1_1 && !inFlight_1_1.done && (_l = inFlight_1.return)) _l.call(inFlight_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        try {
                            for (processedTables_1 = tslib_1.__values(processedTables), processedTables_1_1 = processedTables_1.next(); !processedTables_1_1.done; processedTables_1_1 = processedTables_1.next()) {
                                tableName = processedTables_1_1.value;
                                this.state[tableName].backoffFactor =
                                    Math.max(0, this.state[tableName].backoffFactor - 1);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (processedTables_1_1 && !processedTables_1_1.done && (_m = processedTables_1.return)) _m.call(processedTables_1);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return BatchWrite;
}(BatchOperation_1.BatchOperation));
exports.BatchWrite = BatchWrite;
//# sourceMappingURL=BatchWrite.js.map
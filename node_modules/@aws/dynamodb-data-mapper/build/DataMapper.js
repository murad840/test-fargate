"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var ItemNotFoundException_1 = require("./ItemNotFoundException");
var protocols_1 = require("./protocols");
var dynamodb_batch_iterator_1 = require("@aws/dynamodb-batch-iterator");
var dynamodb_data_marshaller_1 = require("@aws/dynamodb-data-marshaller");
var dynamodb_expressions_1 = require("@aws/dynamodb-expressions");
require('./asyncIteratorSymbolPolyfill');
/**
 * Object mapper for domain object interaction with DynamoDB.
 *
 * To use, define a schema that describes how an item is represented in a
 * DynamoDB table. This schema will be used to marshall a native JavaScript
 * object into its desired persisted form. Attributes present on the object
 * but not in the schema will be ignored.
 */
var DataMapper = /** @class */ (function () {
    function DataMapper(_a) {
        var client = _a.client, _b = _a.readConsistency, readConsistency = _b === void 0 ? 'eventual' : _b, _c = _a.skipVersionCheck, skipVersionCheck = _c === void 0 ? false : _c, _d = _a.tableNamePrefix, tableNamePrefix = _d === void 0 ? '' : _d;
        client.config.customUserAgent = " dynamodb-data-mapper-js/" + constants_1.VERSION;
        this.client = client;
        this.readConsistency = readConsistency;
        this.skipVersionCheck = skipVersionCheck;
        this.tableNamePrefix = tableNamePrefix;
    }
    /**
     * Deletes items from DynamoDB in batches of 25 or fewer via one or more
     * BatchWriteItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any delete requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to delete.
     */
    DataMapper.prototype.batchDelete = function (items) {
        return tslib_1.__asyncGenerator(this, arguments, function batchDelete_1() {
            var iter, iter_1, iter_1_1, _a, _1, unmarshalled, e_1_1, e_1, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        iter = this.batchWrite(function mapToDelete() {
                            return tslib_1.__asyncGenerator(this, arguments, function mapToDelete_1() {
                                var items_1, items_1_1, item, e_2_1, e_2, _a;
                                return tslib_1.__generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            _b.trys.push([0, 7, 8, 13]);
                                            items_1 = tslib_1.__asyncValues(items);
                                            _b.label = 1;
                                        case 1: return [4 /*yield*/, tslib_1.__await(items_1.next())];
                                        case 2:
                                            if (!(items_1_1 = _b.sent(), !items_1_1.done)) return [3 /*break*/, 6];
                                            return [4 /*yield*/, tslib_1.__await(items_1_1.value)];
                                        case 3:
                                            item = _b.sent();
                                            return [4 /*yield*/, ['delete', item]];
                                        case 4:
                                            _b.sent();
                                            _b.label = 5;
                                        case 5: return [3 /*break*/, 1];
                                        case 6: return [3 /*break*/, 13];
                                        case 7:
                                            e_2_1 = _b.sent();
                                            e_2 = { error: e_2_1 };
                                            return [3 /*break*/, 13];
                                        case 8:
                                            _b.trys.push([8, , 11, 12]);
                                            if (!(items_1_1 && !items_1_1.done && (_a = items_1.return))) return [3 /*break*/, 10];
                                            return [4 /*yield*/, tslib_1.__await(_a.call(items_1))];
                                        case 9:
                                            _b.sent();
                                            _b.label = 10;
                                        case 10: return [3 /*break*/, 12];
                                        case 11:
                                            if (e_2) throw e_2.error;
                                            return [7 /*endfinally*/];
                                        case 12: return [7 /*endfinally*/];
                                        case 13: return [2 /*return*/];
                                    }
                                });
                            });
                        }());
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 8, 9, 14]);
                        iter_1 = tslib_1.__asyncValues(iter);
                        _c.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(iter_1.next())];
                    case 3:
                        if (!(iter_1_1 = _c.sent(), !iter_1_1.done)) return [3 /*break*/, 7];
                        return [4 /*yield*/, tslib_1.__await(iter_1_1.value)];
                    case 4:
                        _a = tslib_1.__read.apply(void 0, [_c.sent(), 2]), _1 = _a[0], unmarshalled = _a[1];
                        return [4 /*yield*/, unmarshalled];
                    case 5:
                        _c.sent();
                        _c.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_1_1 = _c.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _c.trys.push([9, , 12, 13]);
                        if (!(iter_1_1 && !iter_1_1.done && (_b = iter_1.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, tslib_1.__await(_b.call(iter_1))];
                    case 10:
                        _c.sent();
                        _c.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves items from DynamoDB in batches of 100 or fewer via one or more
     * BatchGetItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any get requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to get.
     */
    DataMapper.prototype.batchGet = function (items, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.readConsistency, readConsistency = _c === void 0 ? this.readConsistency : _c, _d = _b.perTableOptions, perTableOptions = _d === void 0 ? {} : _d;
        return tslib_1.__asyncGenerator(this, arguments, function batchGet_1() {
            var state, options, batch, batch_1, batch_1_1, _a, tableName, marshalled, _b, keyProperties, itemSchemata, _c, constructor, schema, e_3_1, e_3, _d;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        state = {};
                        options = {};
                        batch = new dynamodb_batch_iterator_1.BatchGet(this.client, this.mapGetBatch(items, state, perTableOptions, options), {
                            ConsistentRead: readConsistency === 'strong',
                            PerTableOptions: options
                        });
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 8, 9, 14]);
                        batch_1 = tslib_1.__asyncValues(batch);
                        _e.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(batch_1.next())];
                    case 3:
                        if (!(batch_1_1 = _e.sent(), !batch_1_1.done)) return [3 /*break*/, 7];
                        return [4 /*yield*/, tslib_1.__await(batch_1_1.value)];
                    case 4:
                        _a = tslib_1.__read.apply(void 0, [_e.sent(), 2]), tableName = _a[0], marshalled = _a[1];
                        _b = state[tableName], keyProperties = _b.keyProperties, itemSchemata = _b.itemSchemata;
                        _c = itemSchemata[itemIdentifier(marshalled, keyProperties)], constructor = _c.constructor, schema = _c.schema;
                        return [4 /*yield*/, dynamodb_data_marshaller_1.unmarshallItem(schema, marshalled, constructor)];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_3_1 = _e.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _e.trys.push([9, , 12, 13]);
                        if (!(batch_1_1 && !batch_1_1.done && (_d = batch_1.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, tslib_1.__await(_d.call(batch_1))];
                    case 10:
                        _e.sent();
                        _e.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Puts items into DynamoDB in batches of 25 or fewer via one or more
     * BatchWriteItem operations. The items may be from any number of tables;
     * tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any put requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of items to put.
     */
    DataMapper.prototype.batchPut = function (items) {
        return tslib_1.__asyncGenerator(this, arguments, function batchPut_1() {
            var generator, _a, _b, _c, _2, unmarshalled, e_4_1, e_4, _d;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        generator = isIterable(items)
                            ? function mapToPut() {
                                var items_2, items_2_1, item, e_5_1, e_5, _a;
                                return tslib_1.__generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            _b.trys.push([0, 5, 6, 7]);
                                            items_2 = tslib_1.__values(items), items_2_1 = items_2.next();
                                            _b.label = 1;
                                        case 1:
                                            if (!!items_2_1.done) return [3 /*break*/, 4];
                                            item = items_2_1.value;
                                            return [4 /*yield*/, ['put', item]];
                                        case 2:
                                            _b.sent();
                                            _b.label = 3;
                                        case 3:
                                            items_2_1 = items_2.next();
                                            return [3 /*break*/, 1];
                                        case 4: return [3 /*break*/, 7];
                                        case 5:
                                            e_5_1 = _b.sent();
                                            e_5 = { error: e_5_1 };
                                            return [3 /*break*/, 7];
                                        case 6:
                                            try {
                                                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);
                                            }
                                            finally { if (e_5) throw e_5.error; }
                                            return [7 /*endfinally*/];
                                        case 7: return [2 /*return*/];
                                    }
                                });
                            }()
                            : function mapToPut() {
                                return tslib_1.__asyncGenerator(this, arguments, function mapToPut_1() {
                                    var items_3, items_3_1, item, e_6_1, e_6, _a;
                                    return tslib_1.__generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0:
                                                _b.trys.push([0, 7, 8, 13]);
                                                items_3 = tslib_1.__asyncValues(items);
                                                _b.label = 1;
                                            case 1: return [4 /*yield*/, tslib_1.__await(items_3.next())];
                                            case 2:
                                                if (!(items_3_1 = _b.sent(), !items_3_1.done)) return [3 /*break*/, 6];
                                                return [4 /*yield*/, tslib_1.__await(items_3_1.value)];
                                            case 3:
                                                item = _b.sent();
                                                return [4 /*yield*/, ['put', item]];
                                            case 4:
                                                _b.sent();
                                                _b.label = 5;
                                            case 5: return [3 /*break*/, 1];
                                            case 6: return [3 /*break*/, 13];
                                            case 7:
                                                e_6_1 = _b.sent();
                                                e_6 = { error: e_6_1 };
                                                return [3 /*break*/, 13];
                                            case 8:
                                                _b.trys.push([8, , 11, 12]);
                                                if (!(items_3_1 && !items_3_1.done && (_a = items_3.return))) return [3 /*break*/, 10];
                                                return [4 /*yield*/, tslib_1.__await(_a.call(items_3))];
                                            case 9:
                                                _b.sent();
                                                _b.label = 10;
                                            case 10: return [3 /*break*/, 12];
                                            case 11:
                                                if (e_6) throw e_6.error;
                                                return [7 /*endfinally*/];
                                            case 12: return [7 /*endfinally*/];
                                            case 13: return [2 /*return*/];
                                        }
                                    });
                                });
                            }();
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 8, 9, 14]);
                        _a = tslib_1.__asyncValues(this.batchWrite(generator));
                        _e.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 7];
                        return [4 /*yield*/, tslib_1.__await(_b.value)];
                    case 4:
                        _c = tslib_1.__read.apply(void 0, [_e.sent(), 2]), _2 = _c[0], unmarshalled = _c[1];
                        return [4 /*yield*/, unmarshalled];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_4_1 = _e.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _e.trys.push([9, , 12, 13]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, tslib_1.__await(_d.call(_a))];
                    case 10:
                        _e.sent();
                        _e.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_4) throw e_4.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Puts or deletes items from DynamoDB in batches of 25 or fewer via one or
     * more BatchWriteItem operations. The items may belong to any number of
     * tables; tables and schemas for each item are determined using the
     * {DynamoDbSchema} property and the {DynamoDbTable} property on defined on
     * each item supplied.
     *
     * This method will automatically retry any write requests returned by
     * DynamoDB as unprocessed. Exponential backoff on unprocessed items is
     * employed on a per-table basis.
     *
     * @param items A synchronous or asynchronous iterable of tuples of the
     * string 'put'|'delete' and the item on which to perform the specified
     * write action.
     */
    DataMapper.prototype.batchWrite = function (items) {
        return tslib_1.__asyncGenerator(this, arguments, function batchWrite_1() {
            var state, batch, batch_2, batch_2_1, _a, tableName, _b, DeleteRequest, PutRequest, _c, keyProperties, itemSchemata, attributes, _d, constructor, schema, e_7_1, e_7, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        state = {};
                        batch = new dynamodb_batch_iterator_1.BatchWrite(this.client, this.mapWriteBatch(items, state));
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 8, 9, 14]);
                        batch_2 = tslib_1.__asyncValues(batch);
                        _f.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(batch_2.next())];
                    case 3:
                        if (!(batch_2_1 = _f.sent(), !batch_2_1.done)) return [3 /*break*/, 7];
                        return [4 /*yield*/, tslib_1.__await(batch_2_1.value)];
                    case 4:
                        _a = tslib_1.__read.apply(void 0, [_f.sent(), 2]), tableName = _a[0], _b = _a[1], DeleteRequest = _b.DeleteRequest, PutRequest = _b.PutRequest;
                        _c = state[tableName], keyProperties = _c.keyProperties, itemSchemata = _c.itemSchemata;
                        attributes = PutRequest
                            ? PutRequest.Item
                            : (DeleteRequest || { Key: {} }).Key;
                        _d = itemSchemata[itemIdentifier(attributes, keyProperties)], constructor = _d.constructor, schema = _d.schema;
                        return [4 /*yield*/, [
                                PutRequest ? 'put' : 'delete',
                                dynamodb_data_marshaller_1.unmarshallItem(schema, attributes, constructor)
                            ]];
                    case 5:
                        _f.sent();
                        _f.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_7_1 = _f.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _f.trys.push([9, , 12, 13]);
                        if (!(batch_2_1 && !batch_2_1.done && (_e = batch_2.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, tslib_1.__await(_e.call(batch_2))];
                    case 10:
                        _f.sent();
                        _f.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Perform a CreateTable operation using the schema accessible via the
     * {DynamoDbSchema} property and the table name accessible via the
     * {DynamoDbTable} property on the prototype of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use.
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the CreateTable operation
     */
    DataMapper.prototype.createTable = function (valueConstructor, _a) {
        var readCapacityUnits = _a.readCapacityUnits, _b = _a.streamViewType, streamViewType = _b === void 0 ? 'NONE' : _b, writeCapacityUnits = _a.writeCapacityUnits, _c = _a.indexOptions, indexOptions = _c === void 0 ? {} : _c;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var schema, _d, attributes, indexKeys, tableKeys, TableName, _e, TableStatus;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        schema = protocols_1.getSchema(valueConstructor.prototype);
                        _d = dynamodb_data_marshaller_1.keysFromSchema(schema), attributes = _d.attributes, indexKeys = _d.indexKeys, tableKeys = _d.tableKeys;
                        TableName = this.getTableName(valueConstructor.prototype);
                        return [4 /*yield*/, this.client.createTable(tslib_1.__assign({}, indexDefinitions(indexKeys, indexOptions, schema), { TableName: TableName, ProvisionedThroughput: {
                                    ReadCapacityUnits: readCapacityUnits,
                                    WriteCapacityUnits: writeCapacityUnits,
                                }, AttributeDefinitions: attributeDefinitionList(attributes), KeySchema: keyTypesToElementList(tableKeys), StreamSpecification: streamViewType === 'NONE'
                                    ? { StreamEnabled: false }
                                    : { StreamEnabled: true, StreamViewType: streamViewType } })).promise()];
                    case 1:
                        _e = (_f.sent()).TableDescription, TableStatus = (_e === void 0 ? { TableStatus: 'CREATING' } : _e).TableStatus;
                        if (!(TableStatus !== 'ACTIVE')) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName }).promise()];
                    case 2:
                        _f.sent();
                        _f.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.delete = function (itemOrParameters, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var item, condition, _a, returnValues, _b, skipVersionCheck, schema, req, _c, _d, prop, inputMember, fieldSchema, versionCondition, attributes, Attributes, e_8, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if ('item' in itemOrParameters &&
                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
                            item = itemOrParameters.item;
                            options = itemOrParameters;
                        }
                        else {
                            item = itemOrParameters;
                        }
                        condition = options.condition, _a = options.returnValues, returnValues = _a === void 0 ? 'ALL_OLD' : _a, _b = options.skipVersionCheck, skipVersionCheck = _b === void 0 ? this.skipVersionCheck : _b;
                        schema = protocols_1.getSchema(item);
                        req = {
                            TableName: this.getTableName(item),
                            Key: dynamodb_data_marshaller_1.marshallKey(schema, item),
                            ReturnValues: returnValues,
                        };
                        if (!skipVersionCheck) {
                            try {
                                for (_c = tslib_1.__values(Object.keys(schema)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    prop = _d.value;
                                    inputMember = item[prop];
                                    fieldSchema = schema[prop];
                                    if (isVersionAttribute(fieldSchema) && inputMember !== undefined) {
                                        versionCondition = handleVersionAttribute(prop, inputMember).condition;
                                        condition = condition
                                            ? { type: 'And', conditions: [condition, versionCondition] }
                                            : versionCondition;
                                    }
                                }
                            }
                            catch (e_8_1) { e_8 = { error: e_8_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                                }
                                finally { if (e_8) throw e_8.error; }
                            }
                        }
                        if (condition) {
                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(condition, schema, attributes).expression;
                            if (Object.keys(attributes.names).length > 0) {
                                req.ExpressionAttributeNames = attributes.names;
                            }
                            if (Object.keys(attributes.values).length > 0) {
                                req.ExpressionAttributeValues = attributes.values;
                            }
                        }
                        return [4 /*yield*/, this.client.deleteItem(req).promise()];
                    case 1:
                        Attributes = (_f.sent()).Attributes;
                        if (Attributes) {
                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, Attributes, item.constructor)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Perform a DeleteTable operation using the schema accessible via the
     * {DynamoDbSchema} property and the table name accessible via the
     * {DynamoDbTable} property on the prototype of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * deleted and can no longer be used.
     *
     * @param valueConstructor  The constructor used for values in the table.
     */
    DataMapper.prototype.deleteTable = function (valueConstructor) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var TableName;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        TableName = this.getTableName(valueConstructor.prototype);
                        return [4 /*yield*/, this.client.deleteTable({ TableName: TableName }).promise()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.client.waitFor('tableNotExists', { TableName: TableName }).promise()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * If the table does not already exist, perform a CreateTable operation
     * using the schema accessible via the {DynamoDbSchema} property and the
     * table name accessible via the {DynamoDbTable} property on the prototype
     * of the constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * active and ready for use.
     *
     * @param valueConstructor  The constructor used for values in the table.
     * @param options           Options to configure the CreateTable operation
     */
    DataMapper.prototype.ensureTableExists = function (valueConstructor, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var TableName, _a, TableStatus, err_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        TableName = this.getTableName(valueConstructor.prototype);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 9]);
                        return [4 /*yield*/, this.client.describeTable({ TableName: TableName }).promise()];
                    case 2:
                        _a = (_b.sent()).Table, TableStatus = (_a === void 0 ? { TableStatus: 'CREATING' } : _a).TableStatus;
                        if (!(TableStatus !== 'ACTIVE')) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName }).promise()];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4: return [3 /*break*/, 9];
                    case 5:
                        err_1 = _b.sent();
                        if (!(err_1.name === 'ResourceNotFoundException')) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.createTable(valueConstructor, options)];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 8];
                    case 7: throw err_1;
                    case 8: return [3 /*break*/, 9];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * If the table exists, perform a DeleteTable operation using the schema
     * accessible via the {DynamoDbSchema} property and the table name
     * accessible via the {DynamoDbTable} property on the prototype of the
     * constructor supplied.
     *
     * The promise returned by this method will not resolve until the table is
     * deleted and can no longer be used.
     *
     * @param valueConstructor  The constructor used for values in the table.
     */
    DataMapper.prototype.ensureTableNotExists = function (valueConstructor) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var TableName, _a, status, err_2;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        TableName = this.getTableName(valueConstructor.prototype);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 8, , 9]);
                        return [4 /*yield*/, this.client.describeTable({ TableName: TableName }).promise()];
                    case 2:
                        _a = (_b.sent()).Table, status = (_a === void 0 ? { TableStatus: 'CREATING' } : _a).TableStatus;
                        if (!(status === 'DELETING')) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.client.waitFor('tableNotExists', { TableName: TableName })
                                .promise()];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                    case 4:
                        if (!(status === 'CREATING' || status === 'UPDATING')) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.client.waitFor('tableExists', { TableName: TableName })
                                .promise()];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [4 /*yield*/, this.deleteTable(valueConstructor)];
                    case 7:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        err_2 = _b.sent();
                        if (err_2.name !== 'ResourceNotFoundException') {
                            throw err_2;
                        }
                        return [3 /*break*/, 9];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.get = function (itemOrParameters, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var item, projection, _a, readConsistency, schema, req, attributes, Item;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if ('item' in itemOrParameters &&
                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
                            item = itemOrParameters.item;
                            options = itemOrParameters;
                        }
                        else {
                            item = itemOrParameters;
                        }
                        projection = options.projection, _a = options.readConsistency, readConsistency = _a === void 0 ? this.readConsistency : _a;
                        schema = protocols_1.getSchema(item);
                        req = {
                            TableName: this.getTableName(item),
                            Key: dynamodb_data_marshaller_1.marshallKey(schema, item),
                            ConsistentRead: readConsistency === 'strong',
                        };
                        if (projection) {
                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
                            req.ProjectionExpression = dynamodb_expressions_1.serializeProjectionExpression(projection.map(function (propName) { return dynamodb_data_marshaller_1.toSchemaName(propName, schema); }), attributes);
                            if (Object.keys(attributes.names).length > 0) {
                                req.ExpressionAttributeNames = attributes.names;
                            }
                        }
                        return [4 /*yield*/, this.client.getItem(req).promise()];
                    case 1:
                        Item = (_b.sent()).Item;
                        if (Item) {
                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, Item, item.constructor)];
                        }
                        throw new ItemNotFoundException_1.ItemNotFoundException(req);
                }
            });
        });
    };
    DataMapper.prototype.parallelScan = function (ctorOrParams, segments, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__asyncGenerator(this, arguments, function parallelScan_1() {
            function addToPending(iterator) {
                var result = iterator.next().then(function (resolved) { return ({
                    iterator: iterator,
                    result: resolved
                }); });
                pendingResults.push({ iterator: iterator, result: result });
            }
            var valueConstructor, req, schema, pendingResults, i, _a, _b, value, done, iterator, i;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (typeof segments !== 'number') {
                            valueConstructor = ctorOrParams.valueConstructor;
                            segments = ctorOrParams.segments;
                            options = ctorOrParams;
                        }
                        else {
                            valueConstructor = ctorOrParams;
                        }
                        req = this.buildScanInput(valueConstructor, options);
                        schema = protocols_1.getSchema(valueConstructor.prototype);
                        pendingResults = [];
                        for (i = 0; i < segments; i++) {
                            addToPending(this.doSequentialScan(tslib_1.__assign({}, req, { TotalSegments: segments, Segment: i }), schema, valueConstructor));
                        }
                        _c.label = 1;
                    case 1:
                        if (!(pendingResults.length > 0)) return [3 /*break*/, 5];
                        return [4 /*yield*/, tslib_1.__await(Promise.race(pendingResults.map(function (val) { return val.result; })))];
                    case 2:
                        _a = _c.sent(), _b = _a.result, value = _b.value, done = _b.done, iterator = _a.iterator;
                        for (i = pendingResults.length - 1; i >= 0; i--) {
                            if (pendingResults[i].iterator === iterator) {
                                pendingResults.splice(i, 1);
                            }
                        }
                        if (!!done) return [3 /*break*/, 4];
                        addToPending(iterator);
                        return [4 /*yield*/, value];
                    case 3:
                        _c.sent();
                        _c.label = 4;
                    case 4: return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.put = function (itemOrParameters, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var item, condition, _a, skipVersionCheck, schema, req, _b, _c, key, inputMember, fieldSchema, _d, attributeName, versionCond, attributes, e_9, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if ('item' in itemOrParameters &&
                            itemOrParameters.item[protocols_1.DynamoDbTable]) {
                            item = itemOrParameters.item;
                            options = itemOrParameters;
                        }
                        else {
                            item = itemOrParameters;
                        }
                        condition = options.condition, _a = options.skipVersionCheck, skipVersionCheck = _a === void 0 ? this.skipVersionCheck : _a;
                        schema = protocols_1.getSchema(item);
                        req = {
                            TableName: this.getTableName(item),
                            Item: dynamodb_data_marshaller_1.marshallItem(schema, item),
                        };
                        if (!skipVersionCheck) {
                            try {
                                for (_b = tslib_1.__values(Object.keys(schema)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    key = _c.value;
                                    inputMember = item[key];
                                    fieldSchema = schema[key];
                                    _d = fieldSchema.attributeName, attributeName = _d === void 0 ? key : _d;
                                    if (isVersionAttribute(fieldSchema)) {
                                        versionCond = handleVersionAttribute(key, inputMember).condition;
                                        if (req.Item[attributeName]) {
                                            req.Item[attributeName].N = (Number(req.Item[attributeName].N) + 1).toString();
                                        }
                                        else {
                                            req.Item[attributeName] = { N: "0" };
                                        }
                                        condition = condition
                                            ? { type: 'And', conditions: [condition, versionCond] }
                                            : versionCond;
                                    }
                                }
                            }
                            catch (e_9_1) { e_9 = { error: e_9_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                                }
                                finally { if (e_9) throw e_9.error; }
                            }
                        }
                        if (condition) {
                            attributes = new dynamodb_expressions_1.ExpressionAttributes();
                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(condition, schema, attributes).expression;
                            if (Object.keys(attributes.names).length > 0) {
                                req.ExpressionAttributeNames = attributes.names;
                            }
                            if (Object.keys(attributes.values).length > 0) {
                                req.ExpressionAttributeValues = attributes.values;
                            }
                        }
                        return [4 /*yield*/, this.client.putItem(req).promise()];
                    case 1:
                        _f.sent();
                        return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, req.Item, item.constructor)];
                }
            });
        });
    };
    DataMapper.prototype.query = function (valueConstructorOrParameters, keyCondition, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__asyncGenerator(this, arguments, function query_1() {
            var valueConstructor, filter, indexName, limit, _a, pageSize, projection, _b, readConsistency, scanIndexForward, startKey, req, schema, attributes, result, _c, _d, item, e_10_1, e_10, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!keyCondition) {
                            valueConstructor = valueConstructorOrParameters.valueConstructor;
                            keyCondition = valueConstructorOrParameters.keyCondition;
                            options = valueConstructorOrParameters;
                        }
                        else {
                            valueConstructor = valueConstructorOrParameters;
                        }
                        filter = options.filter, indexName = options.indexName, limit = options.limit, _a = options.pageSize, pageSize = _a === void 0 ? limit : _a, projection = options.projection, _b = options.readConsistency, readConsistency = _b === void 0 ? this.readConsistency : _b, scanIndexForward = options.scanIndexForward, startKey = options.startKey;
                        req = {
                            TableName: this.getTableName(valueConstructor.prototype),
                            ConsistentRead: readConsistency === 'strong',
                            ScanIndexForward: scanIndexForward,
                            Limit: pageSize,
                            IndexName: indexName,
                        };
                        schema = protocols_1.getSchema(valueConstructor.prototype);
                        attributes = new dynamodb_expressions_1.ExpressionAttributes();
                        req.KeyConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(normalizeKeyCondition(keyCondition), schema, attributes).expression;
                        if (filter) {
                            req.FilterExpression = dynamodb_data_marshaller_1.marshallConditionExpression(filter, schema, attributes).expression;
                        }
                        if (projection) {
                            req.ProjectionExpression = dynamodb_data_marshaller_1.marshallProjectionExpression(projection, schema, attributes).expression;
                        }
                        if (Object.keys(attributes.names).length > 0) {
                            req.ExpressionAttributeNames = attributes.names;
                        }
                        if (Object.keys(attributes.values).length > 0) {
                            req.ExpressionAttributeValues = attributes.values;
                        }
                        if (startKey) {
                            req.ExclusiveStartKey = dynamodb_data_marshaller_1.marshallKey(schema, startKey, indexName);
                        }
                        _f.label = 1;
                    case 1: return [4 /*yield*/, tslib_1.__await(this.client.query(req).promise())];
                    case 2:
                        result = _f.sent();
                        req.ExclusiveStartKey = result.LastEvaluatedKey;
                        if (!result.Items) return [3 /*break*/, 10];
                        _f.label = 3;
                    case 3:
                        _f.trys.push([3, 8, 9, 10]);
                        _c = tslib_1.__values(result.Items), _d = _c.next();
                        _f.label = 4;
                    case 4:
                        if (!!_d.done) return [3 /*break*/, 7];
                        item = _d.value;
                        return [4 /*yield*/, dynamodb_data_marshaller_1.unmarshallItem(schema, item, valueConstructor)];
                    case 5:
                        _f.sent();
                        _f.label = 6;
                    case 6:
                        _d = _c.next();
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_10_1 = _f.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_10) throw e_10.error; }
                        return [7 /*endfinally*/];
                    case 10:
                        if (result.LastEvaluatedKey !== undefined) return [3 /*break*/, 1];
                        _f.label = 11;
                    case 11: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.scan = function (ctorOrParams, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__asyncGenerator(this, arguments, function scan_1() {
            var valueConstructor, req, schema;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ('valueConstructor' in ctorOrParams &&
                            ctorOrParams.valueConstructor.prototype &&
                            ctorOrParams.valueConstructor.prototype[protocols_1.DynamoDbTable]) {
                            valueConstructor = ctorOrParams.valueConstructor;
                            options = ctorOrParams;
                        }
                        else {
                            valueConstructor = ctorOrParams;
                        }
                        req = this.buildScanInput(valueConstructor, options);
                        schema = protocols_1.getSchema(valueConstructor.prototype);
                        return [5 /*yield**/, tslib_1.__values(tslib_1.__asyncDelegator(tslib_1.__asyncValues(this.doSequentialScan(req, schema, valueConstructor))))];
                    case 1: return [4 /*yield*/, tslib_1.__await.apply(void 0, [_a.sent()])];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.update = function (itemOrParameters, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var item, condition, _a, onMissing, _b, skipVersionCheck, schema, expr, itemKey, _c, _d, key, inputMember, fieldSchema, _e, versionCond, value, marshalled, e_11, _f;
            return tslib_1.__generator(this, function (_g) {
                if ('item' in itemOrParameters &&
                    itemOrParameters.item[protocols_1.DynamoDbTable]) {
                    item = itemOrParameters.item;
                    options = itemOrParameters;
                }
                else {
                    item = itemOrParameters;
                }
                condition = options.condition, _a = options.onMissing, onMissing = _a === void 0 ? 'remove' : _a, _b = options.skipVersionCheck, skipVersionCheck = _b === void 0 ? this.skipVersionCheck : _b;
                schema = protocols_1.getSchema(item);
                expr = new dynamodb_expressions_1.UpdateExpression();
                itemKey = {};
                try {
                    for (_c = tslib_1.__values(Object.keys(schema)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        key = _d.value;
                        inputMember = item[key];
                        fieldSchema = schema[key];
                        if (dynamodb_data_marshaller_1.isKey(fieldSchema)) {
                            itemKey[key] = inputMember;
                        }
                        else if (isVersionAttribute(fieldSchema)) {
                            _e = handleVersionAttribute(key, inputMember), versionCond = _e.condition, value = _e.value;
                            expr.set(key, value);
                            if (!skipVersionCheck) {
                                condition = condition
                                    ? { type: 'And', conditions: [condition, versionCond] }
                                    : versionCond;
                            }
                        }
                        else if (inputMember === undefined) {
                            if (onMissing === 'remove') {
                                expr.remove(key);
                            }
                        }
                        else {
                            marshalled = dynamodb_data_marshaller_1.marshallValue(fieldSchema, inputMember);
                            if (marshalled) {
                                expr.set(key, new dynamodb_expressions_1.AttributeValue(marshalled));
                            }
                        }
                    }
                }
                catch (e_11_1) { e_11 = { error: e_11_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                    }
                    finally { if (e_11) throw e_11.error; }
                }
                return [2 /*return*/, this.doExecuteUpdateExpression(expr, itemKey, protocols_1.getSchema(item), protocols_1.getTableName(item), item.constructor, { condition: condition })];
            });
        });
    };
    /**
     * Execute a custom update expression using the schema and table name
     * defined on the provided `valueConstructor`.
     *
     * This method does not support automatic version checking, as the current
     * state of a table's version attribute cannot be inferred from an update
     * expression object. To perform a version check manually, add a condition
     * expression:
     *
     * ```typescript
     *  const currentVersion = 1;
     *  updateExpression.set('nameOfVersionAttribute', currentVersion + 1);
     *  const condition = {
     *      type: 'Equals',
     *      subject: 'nameOfVersionAttribute',
     *      object: currentVersion
     *  };
     *
     *  const updated = await mapper.executeUpdateExpression(
     *      updateExpression,
     *      itemKey,
     *      constructor,
     *      {condition}
     *  );
     * ```
     *
     * **NB:** Property names and attribute paths in the update expression
     * should reflect the names used in the schema.
     *
     * @param expression        The update expression to execute.
     * @param key               The full key to identify the object being
     *                          updated.
     * @param valueConstructor  The constructor with which to map the result to
     *                          a domain object.
     * @param options           Options with which to customize the UpdateItem
     *                          request.
     *
     * @returns The updated item.
     */
    DataMapper.prototype.executeUpdateExpression = function (expression, key, valueConstructor, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.doExecuteUpdateExpression(expression, key, protocols_1.getSchema(valueConstructor.prototype), protocols_1.getTableName(valueConstructor.prototype), valueConstructor, options)];
            });
        });
    };
    DataMapper.prototype.doExecuteUpdateExpression = function (expression, key, schema, tableName, valueConstructor, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, attributes, rawResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        req = {
                            TableName: this.tableNamePrefix + tableName,
                            ReturnValues: 'ALL_NEW',
                            Key: dynamodb_data_marshaller_1.marshallKey(schema, key),
                        };
                        attributes = new dynamodb_expressions_1.ExpressionAttributes();
                        if (options.condition) {
                            req.ConditionExpression = dynamodb_data_marshaller_1.marshallConditionExpression(options.condition, schema, attributes).expression;
                        }
                        req.UpdateExpression = dynamodb_data_marshaller_1.marshallUpdateExpression(expression, schema, attributes).expression;
                        if (Object.keys(attributes.names).length > 0) {
                            req.ExpressionAttributeNames = attributes.names;
                        }
                        if (Object.keys(attributes.values).length > 0) {
                            req.ExpressionAttributeValues = attributes.values;
                        }
                        return [4 /*yield*/, this.client.updateItem(req).promise()];
                    case 1:
                        rawResponse = _a.sent();
                        if (rawResponse.Attributes) {
                            return [2 /*return*/, dynamodb_data_marshaller_1.unmarshallItem(schema, rawResponse.Attributes, valueConstructor)];
                        }
                        // this branch should not be reached when interacting with DynamoDB, as
                        // the ReturnValues parameter is hardcoded to 'ALL_NEW' above. It is,
                        // however, allowed by the service model and may therefore occur in
                        // certain unforeseen conditions; to be safe, this case should be
                        // converted into an error unless a compelling reason to return
                        // undefined or an empty object presents itself.
                        throw new Error('Update operation completed successfully, but the updated value was not returned');
                }
            });
        });
    };
    DataMapper.prototype.buildScanInput = function (valueConstructor, _a) {
        var filter = _a.filter, indexName = _a.indexName, limit = _a.limit, _b = _a.pageSize, pageSize = _b === void 0 ? limit : _b, projection = _a.projection, _c = _a.readConsistency, readConsistency = _c === void 0 ? this.readConsistency : _c, segment = _a.segment, startKey = _a.startKey, totalSegments = _a.totalSegments;
        var req = {
            TableName: this.getTableName(valueConstructor.prototype),
            ConsistentRead: readConsistency === 'strong',
            Limit: pageSize,
            IndexName: indexName,
            Segment: segment,
            TotalSegments: totalSegments,
        };
        var schema = protocols_1.getSchema(valueConstructor.prototype);
        var attributes = new dynamodb_expressions_1.ExpressionAttributes();
        if (filter) {
            req.FilterExpression = dynamodb_data_marshaller_1.marshallConditionExpression(filter, schema, attributes).expression;
        }
        if (projection) {
            req.ProjectionExpression = dynamodb_data_marshaller_1.marshallProjectionExpression(projection, schema, attributes).expression;
        }
        if (Object.keys(attributes.names).length > 0) {
            req.ExpressionAttributeNames = attributes.names;
        }
        if (Object.keys(attributes.values).length > 0) {
            req.ExpressionAttributeValues = attributes.values;
        }
        if (startKey) {
            req.ExclusiveStartKey = dynamodb_data_marshaller_1.marshallKey(schema, startKey, indexName);
        }
        return req;
    };
    DataMapper.prototype.doSequentialScan = function (req, schema, ctor) {
        return tslib_1.__asyncGenerator(this, arguments, function doSequentialScan_1() {
            var result, _a, _b, item, e_12_1, e_12, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, tslib_1.__await(this.client.scan(req).promise())];
                    case 1:
                        result = _d.sent();
                        req.ExclusiveStartKey = result.LastEvaluatedKey;
                        if (!result.Items) return [3 /*break*/, 9];
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 7, 8, 9]);
                        _a = tslib_1.__values(result.Items), _b = _a.next();
                        _d.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 6];
                        item = _b.value;
                        return [4 /*yield*/, dynamodb_data_marshaller_1.unmarshallItem(schema, item, ctor)];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_12_1 = _d.sent();
                        e_12 = { error: e_12_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_12) throw e_12.error; }
                        return [7 /*endfinally*/];
                    case 9:
                        if (result.LastEvaluatedKey !== undefined) return [3 /*break*/, 0];
                        _d.label = 10;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.getTableName = function (item) {
        return protocols_1.getTableName(item, this.tableNamePrefix);
    };
    DataMapper.prototype.mapGetBatch = function (items, state, options, convertedOptions) {
        return tslib_1.__asyncGenerator(this, arguments, function mapGetBatch_1() {
            var items_4, items_4_1, item, unprefixed, tableName, schema, _a, keyProperties, itemSchemata, marshalled, e_13_1, e_13, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 7, 8, 13]);
                        items_4 = tslib_1.__asyncValues(items);
                        _c.label = 1;
                    case 1: return [4 /*yield*/, tslib_1.__await(items_4.next())];
                    case 2:
                        if (!(items_4_1 = _c.sent(), !items_4_1.done)) return [3 /*break*/, 6];
                        return [4 /*yield*/, tslib_1.__await(items_4_1.value)];
                    case 3:
                        item = _c.sent();
                        unprefixed = protocols_1.getTableName(item);
                        tableName = this.tableNamePrefix + unprefixed;
                        schema = protocols_1.getSchema(item);
                        if (unprefixed in options && !(tableName in convertedOptions)) {
                            convertedOptions[tableName] = convertBatchGetOptions(options[unprefixed], schema);
                        }
                        if (!(tableName in state)) {
                            state[tableName] = {
                                keyProperties: getKeyProperties(schema),
                                itemSchemata: {}
                            };
                        }
                        _a = state[tableName], keyProperties = _a.keyProperties, itemSchemata = _a.itemSchemata;
                        marshalled = dynamodb_data_marshaller_1.marshallKey(schema, item);
                        itemSchemata[itemIdentifier(marshalled, keyProperties)] = {
                            constructor: item.constructor,
                            schema: schema,
                        };
                        return [4 /*yield*/, [tableName, marshalled]];
                    case 4:
                        _c.sent();
                        _c.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_13_1 = _c.sent();
                        e_13 = { error: e_13_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _c.trys.push([8, , 11, 12]);
                        if (!(items_4_1 && !items_4_1.done && (_b = items_4.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib_1.__await(_b.call(items_4))];
                    case 9:
                        _c.sent();
                        _c.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_13) throw e_13.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    DataMapper.prototype.mapWriteBatch = function (items, state) {
        return tslib_1.__asyncGenerator(this, arguments, function mapWriteBatch_1() {
            var items_5, items_5_1, _a, type, item, unprefixed, tableName, schema, _b, keyProperties, itemSchemata, attributes, marshalled, e_14_1, e_14, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        items_5 = tslib_1.__asyncValues(items);
                        _d.label = 1;
                    case 1: return [4 /*yield*/, tslib_1.__await(items_5.next())];
                    case 2:
                        if (!(items_5_1 = _d.sent(), !items_5_1.done)) return [3 /*break*/, 6];
                        return [4 /*yield*/, tslib_1.__await(items_5_1.value)];
                    case 3:
                        _a = tslib_1.__read.apply(void 0, [_d.sent(), 2]), type = _a[0], item = _a[1];
                        unprefixed = protocols_1.getTableName(item);
                        tableName = this.tableNamePrefix + unprefixed;
                        schema = protocols_1.getSchema(item);
                        if (!(tableName in state)) {
                            state[tableName] = {
                                keyProperties: getKeyProperties(schema),
                                itemSchemata: {}
                            };
                        }
                        _b = state[tableName], keyProperties = _b.keyProperties, itemSchemata = _b.itemSchemata;
                        attributes = type === 'delete'
                            ? dynamodb_data_marshaller_1.marshallKey(schema, item)
                            : dynamodb_data_marshaller_1.marshallItem(schema, item);
                        marshalled = type === 'delete'
                            ? { DeleteRequest: { Key: attributes } }
                            : { PutRequest: { Item: attributes } };
                        itemSchemata[itemIdentifier(attributes, keyProperties)] = {
                            constructor: item.constructor,
                            schema: schema,
                        };
                        return [4 /*yield*/, [tableName, marshalled]];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_14_1 = _d.sent();
                        e_14 = { error: e_14_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(items_5_1 && !items_5_1.done && (_c = items_5.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib_1.__await(_c.call(items_5))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_14) throw e_14.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    return DataMapper;
}());
exports.DataMapper = DataMapper;
function attributeDefinitionList(attributes) {
    return Object.keys(attributes).map(function (name) { return ({
        AttributeName: name,
        AttributeType: attributes[name]
    }); });
}
function convertBatchGetOptions(options, itemSchema) {
    var out = {};
    if (options.readConsistency) {
        out.ConsistentRead = options.readConsistency === 'strong';
    }
    if (options.projection) {
        var attributes = new dynamodb_expressions_1.ExpressionAttributes();
        out.ProjectionExpression = dynamodb_expressions_1.serializeProjectionExpression(options.projection.map(function (propName) { return dynamodb_data_marshaller_1.toSchemaName(propName, options.projectionSchema || itemSchema); }), attributes);
        out.ExpressionAttributeNames = attributes.names;
    }
    return out;
}
function getKeyProperties(schema) {
    var keys = [];
    try {
        for (var _a = tslib_1.__values(Object.keys(schema).sort()), _b = _a.next(); !_b.done; _b = _a.next()) {
            var property = _b.value;
            var fieldSchema = schema[property];
            if (dynamodb_data_marshaller_1.isKey(fieldSchema)) {
                keys.push(fieldSchema.attributeName || property);
            }
        }
    }
    catch (e_15_1) { e_15 = { error: e_15_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_15) throw e_15.error; }
    }
    return keys;
    var e_15, _c;
}
function handleVersionAttribute(attributeName, inputMember) {
    var condition;
    var value;
    if (inputMember === undefined) {
        condition = new dynamodb_expressions_1.FunctionExpression('attribute_not_exists', new dynamodb_expressions_1.AttributePath([
            { type: 'AttributeName', name: attributeName }
        ]));
        value = new dynamodb_expressions_1.AttributeValue({ N: "0" });
    }
    else {
        condition = {
            type: 'Equals',
            subject: attributeName,
            object: inputMember,
        };
        value = new dynamodb_expressions_1.MathematicalExpression(new dynamodb_expressions_1.AttributePath(attributeName), '+', 1);
    }
    return { condition: condition, value: value };
}
function indexDefinitions(keys, options, schema) {
    var globalIndices = [];
    var localIndices = [];
    try {
        for (var _a = tslib_1.__values(Object.keys(keys)), _b = _a.next(); !_b.done; _b = _a.next()) {
            var IndexName = _b.value;
            var KeySchema = keyTypesToElementList(keys[IndexName]);
            var indexOptions = options[IndexName];
            if (!indexOptions) {
                throw new Error("No options provided for " + IndexName + " index");
            }
            var indexInfo = {
                IndexName: IndexName,
                KeySchema: KeySchema,
                Projection: indexProjection(schema, indexOptions.projection),
            };
            if (indexOptions.type === 'local') {
                localIndices.push(indexInfo);
            }
            else {
                globalIndices.push(tslib_1.__assign({}, indexInfo, { ProvisionedThroughput: {
                        ReadCapacityUnits: indexOptions.readCapacityUnits,
                        WriteCapacityUnits: indexOptions.writeCapacityUnits,
                    } }));
            }
        }
    }
    catch (e_16_1) { e_16 = { error: e_16_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_16) throw e_16.error; }
    }
    return {
        GlobalSecondaryIndexes: globalIndices.length ? globalIndices : void 0,
        LocalSecondaryIndexes: localIndices.length ? localIndices : void 0,
    };
    var e_16, _c;
}
function indexProjection(schema, projection) {
    if (typeof projection === 'string') {
        return {
            ProjectionType: projection === 'all' ? 'ALL' : 'KEYS_ONLY',
        };
    }
    return {
        ProjectionType: 'INCLUDE',
        NonKeyAttributes: projection.map(function (propName) { return dynamodb_data_marshaller_1.getSchemaName(propName, schema); })
    };
}
function isIterable(arg) {
    return Boolean(arg) && typeof arg[Symbol.iterator] === 'function';
}
function isVersionAttribute(fieldSchema) {
    return fieldSchema.type === 'Number'
        && Boolean(fieldSchema.versionAttribute);
}
function itemIdentifier(marshalled, keyProperties) {
    var keyAttributes = [];
    try {
        for (var keyProperties_1 = tslib_1.__values(keyProperties), keyProperties_1_1 = keyProperties_1.next(); !keyProperties_1_1.done; keyProperties_1_1 = keyProperties_1.next()) {
            var key = keyProperties_1_1.value;
            var value = marshalled[key];
            key + "=" + (value.B || value.N || value.S);
        }
    }
    catch (e_17_1) { e_17 = { error: e_17_1 }; }
    finally {
        try {
            if (keyProperties_1_1 && !keyProperties_1_1.done && (_a = keyProperties_1.return)) _a.call(keyProperties_1);
        }
        finally { if (e_17) throw e_17.error; }
    }
    return keyAttributes.join(':');
    var e_17, _a;
}
function keyTypesToElementList(keys) {
    return Object.keys(keys).map(function (name) { return ({
        AttributeName: name,
        KeyType: keys[name]
    }); });
}
function normalizeKeyCondition(keyCondition) {
    if (dynamodb_expressions_1.isConditionExpression(keyCondition)) {
        return keyCondition;
    }
    var conditions = [];
    try {
        for (var _a = tslib_1.__values(Object.keys(keyCondition)), _b = _a.next(); !_b.done; _b = _a.next()) {
            var property = _b.value;
            var predicate = keyCondition[property];
            if (dynamodb_expressions_1.isConditionExpressionPredicate(predicate)) {
                conditions.push(tslib_1.__assign({}, predicate, { subject: property }));
            }
            else {
                conditions.push({
                    type: 'Equals',
                    subject: property,
                    object: predicate,
                });
            }
        }
    }
    catch (e_18_1) { e_18 = { error: e_18_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_18) throw e_18.error; }
    }
    if (conditions.length === 1) {
        return conditions[0];
    }
    return { type: 'And', conditions: conditions };
    var e_18, _c;
}
//# sourceMappingURL=DataMapper.js.map